# pi_client.py 完全解説（初心者向け）

このドキュメントでは、`pi_client.py`の動作とエラー処理について、初心者でもわかりやすく解説します。

---

## 📋 目次

1. [全体の流れ](#全体の流れ)
2. [主要なクラス](#主要なクラス)
3. [エラー処理の考え方](#エラー処理の考え方)
4. [動作フロー](#動作フロー)
5. [エラーメッセージの見方](#エラーメッセージの見方)
6. [トラブルシューティング](#トラブルシューティング)

---

## 🔄 全体の流れ

### プログラムの起動から終了まで

```
1. プログラム起動
   ↓
2. 必要なモジュールを読み込む（エラーがあっても継続）
   ↓
3. SimpleClientクラスを初期化
   ├─ データベース初期化
   ├─ GPIO初期化（失敗してもプログラムは継続）
   ├─ LCD初期化（失敗してもプログラムは継続）
   └─ サーバー接続チェック
   ↓
4. カードリーダーを検出
   ├─ nfcpyリーダーを検出
   └─ PC/SCリーダーを検出
   ↓
5. カード読み取り待機（無限ループ）
   ├─ カードが検出されたら
   │   ├─ カードIDを取得
   │   ├─ 重複チェック
   │   ├─ サーバーに送信（成功/失敗）
   │   └─ データベースに保存
   └─ エラーが発生しても継続
   ↓
6. Ctrl+Cで終了
```

---

## 🏗️ 主要なクラス

### 1. SimpleDatabase（データベース管理）

**役割**: 打刻データをSQLiteデータベースに保存・取得

```python
class SimpleDatabase:
    def __init__(self):
        # データベースを初期化（テーブルを作成）
    
    def save(self, idm, timestamp, terminal_id, sent_to_server=0):
        # 打刻データを保存
        # エラー: 基本的には発生しない（SQLiteはファイルベース）
    
    def get_pending(self, limit=None):
        # 未送信データを取得
    
    def mark_sent(self, record_id):
        # 送信済みマークを付ける
```

**エラー処理**: 
- データベースファイルが作成できない場合 → プログラムは停止（通常は発生しない）

---

### 2. SimpleGPIO（GPIO制御：LED/ブザー）

**役割**: LEDの色を変更、ブザーを鳴らす

```python
class SimpleGPIO:
    def __init__(self):
        # GPIO初期化
        # エラー時: available = False（プログラムは継続）
    
    def sound(self, pattern):
        # ブザーを鳴らす
        # エラー時: ログを出力して継続
    
    def led(self, color):
        # LEDの色を設定
        # エラー時: ログを出力して継続
    
    def led_blink(self, color, times=3):
        # LEDを点滅させる
```

**エラー処理の特徴**:
- ✅ **GPIO初期化失敗** → `available = False` にして、プログラムは継続
- ✅ **LED制御エラー** → ログを出力して、プログラムは継続
- ✅ **ブザー制御エラー** → ログを出力して、プログラムは継続

**重要なポイント**: GPIOが使えなくても、カード読み取りは動作します

---

### 3. SimpleClient（メインロジック）

**役割**: カード読み取り、サーバー送信、データベース保存を統括

#### 3.1. 初期化（`__init__`）

```python
def __init__(self, server_url=None, retry_interval=None, lcd_settings=None):
    # 1. 設定ファイルを読み込む
    # 2. データベースを初期化
    # 3. GPIOを初期化（失敗しても継続）
    # 4. LCDを初期化（失敗しても継続）
    # 5. サーバー接続をチェック
    # 6. バックグラウンドスレッドを起動
```

**エラー処理**:
- ✅ LCD初期化失敗 → `self.lcd = None` にして継続
- ✅ GPIO初期化失敗 → `self.gpio.available = False` にして継続
- ❌ データベース初期化失敗 → プログラム停止（通常は発生しない）

#### 3.2. カード処理（`process_card`）

**処理の流れ**:

```
1. 重複チェック（同じカードが同時に処理されないように）
   ↓
2. フィードバック（ブザー、LED、LCD表示）
   ↓
3. 重複打刻チェック（同じhh:mmで既に打刻済みか）
   ├─ 重複の場合: エラー表示して終了
   └─ 重複でない場合: 続行
   ↓
4. サーバーに送信
   ├─ 成功: データベースに「送信済み」として保存
   └─ 失敗: データベースに「未送信」として保存
   ↓
5. フィードバック（成功/失敗に応じたLED、ブザー）
```

**エラー処理**:
- ✅ GPIO制御エラー → ログを出力して継続
- ✅ LCD表示エラー → ログを出力して継続
- ✅ サーバー送信失敗 → ローカルに保存して継続

#### 3.3. カード読み取り（`nfcpy_worker` / `pcsc_worker`）

**処理の流れ**:

```
while self.running:  # 無限ループ
    try:
        # カードを検出
        if カードが検出された:
            # カードIDを取得
            # 重複チェック（2秒以内の重複を防ぐ）
            if 新しいカード:
                # process_card()を呼び出す
    except IOError:
        # カードが離れた（正常な動作）
        pass
    except Exception:
        # 予期しないエラー
        # ログを出力して継続
    time.sleep(0.1)  # 少し待ってから再試行
```

**エラー処理**:
- ✅ **IOError** → カードが離れただけ（正常）→ 継続
- ✅ **Exception** → 予期しないエラー → ログを出力して継続
- ✅ **リーダーが見つからない** → 無限ループを継続（後で接続される可能性）

**重要なポイント**: エラーが発生しても、プログラムは停止しません。再試行し続けます。

---

## 🛡️ エラー処理の考え方

### エラー処理の3つのレベル

#### レベル1: 致命的なエラー（プログラム停止）

```
- データベース初期化失敗
- メインファイルの読み込みエラー
```

**対処**: エラーメッセージを表示してプログラムを終了

#### レベル2: 機能の無効化（プログラム継続）

```
- GPIO初期化失敗 → GPIO機能を無効化
- LCD初期化失敗 → LCD機能を無効化
- モジュールインポート失敗 → その機能を無効化
```

**対処**: 機能を無効化して、他の機能は継続

#### レベル3: 一時的なエラー（再試行）

```
- カード読み取りエラー → 再試行
- サーバー送信失敗 → ローカルに保存して後で再送信
- リーダー接続エラー → 再試行
```

**対処**: エラーを記録して、処理を継続（後で自動的に再試行）

---

## 🔍 動作フロー

### カードが検出されたときの詳細な流れ

```
[カード検出]
  ↓
[nfcpy_worker または pcsc_worker]
  ├─ カードIDを取得
  └─ 重複チェック（2秒以内の重複を防ぐ）
      ↓
[process_card() を呼び出す]
  ├─ 重複チェック（同じカードが同時に処理されないように）
  │   └─ 既に処理中 → 終了
  │
  ├─ フィードバック開始
  │   ├─ gpio.sound("card_read")  # ブザー
  │   ├─ gpio.led("green")        # LED緑
  │   └─ lcd.show("Reading...")   # LCD表示
  │
  ├─ 重複打刻チェック
  │   ├─ 同じhh:mmで既に打刻済み？
  │   │   ├─ Yes → エラー表示して終了
  │   │   └─ No → 続行
  │
  ├─ サーバーに送信
  │   ├─ 成功
  │   │   ├─ database.save(..., sent_to_server=1)
  │   │   ├─ gpio.sound("success")
  │   │   ├─ gpio.led_blink("cyan", times=3)
  │   │   ├─ gpio.led("cyan")
  │   │   └─ lcd.show("Sending...")
  │   │
  │   └─ 失敗
  │       ├─ database.save(..., sent_to_server=0)
  │       ├─ gpio.sound("failure")
  │       ├─ gpio.led("red")
  │       └─ lcd.show("Saved Local")
  │
  └─ 処理完了
      └─ processing_cardsから削除
```

---

## 📢 エラーメッセージの見方

### エラーメッセージの種類

#### 1. 情報メッセージ（[情報]）

```
[情報] LCD機能無効
[情報] GPIO機能無効
[情報] nfcpy未インストール - PC/SCのみで動作
```

**意味**: オプション機能が無効になっているだけ（正常）

**対処**: 必要なければ無視でOK

#### 2. 警告メッセージ（[警告]）

```
[警告] requests未インストール - サーバー送信機能は無効です
[警告] GPIO機能が無効です - LEDとブザーは動作しません
```

**意味**: 機能が使えない（プログラムは継続）

**対処**: 必要ならインストール/設定を確認

#### 3. エラーメッセージ（[エラー]）

```
[エラー] カードリーダーが見つかりません
[nfcpyエラー] Connection refused
[PC/SCエラー] No card present
```

**意味**: 問題が発生している（プログラムは継続）

**対処**: 原因を確認して修正

#### 4. デバッグメッセージ（[GPIO] / [LCD] / [DB]）

```
[GPIO] 初期化成功
[GPIO] ブザー無効: pattern=card_read
[LCD] 初期化失敗: Permission denied - LCD機能を無効化
[DB] 初期化完了: attendance.db
```

**意味**: 各機能の状態を示す（デバッグ用）

**対処**: 問題があれば確認

---

## 🔧 トラブルシューティング

### よくあるエラーと対処法

#### 1. GPIO関連のエラー

**エラーメッセージ**:
```
[GPIO] 初期化失敗: No module named 'RPi'
[GPIO] ブザー無効: pattern=card_read
[GPIO] LED無効: color=green
```

**原因**:
- `RPi.GPIO`がインストールされていない
- 仮想環境で実行していない
- GPIOピンが正しく接続されていない

**対処法**:
```bash
# 仮想環境を有効化
source venv/bin/activate

# RPi.GPIOをインストール
pip install RPi.GPIO

# GPIOピンの接続を確認
gpio readall
```

**重要**: GPIOが使えなくても、カード読み取りは動作します。

---

#### 2. カードリーダー関連のエラー

**エラーメッセージ**:
```
[エラー] カードリーダーが見つかりません
[nfcpyエラー] Connection refused
[PC/SCエラー] No card present
```

**原因**:
- カードリーダーが接続されていない
- USBデバイスが認識されていない
- PC/SCサービスが起動していない

**対処法**:
```bash
# USBデバイスを確認
lsusb

# PC/SCサービスを確認
systemctl status pcscd

# PC/SCサービスを起動
sudo systemctl start pcscd
```

---

#### 3. サーバー送信関連のエラー

**エラーメッセージ**:
```
[警告] requests未インストール - サーバー送信機能は無効です
[保存] 0123456789ABCDEF (オフライン)
```

**原因**:
- `requests`がインストールされていない
- サーバーに接続できない
- ネットワークエラー

**対処法**:
```bash
# requestsをインストール
pip install requests

# サーバー接続を確認
curl http://192.168.1.31:5000/api/health
```

**重要**: サーバー送信に失敗しても、ローカルに保存されます。後で自動的に再送信されます。

---

#### 4. データベース関連のエラー

**エラーメッセージ**:
```
[DB] 初期化完了: attendance.db
```

**注意**: データベースエラーは通常発生しませんが、発生した場合は：

**対処法**:
```bash
# データベースファイルの権限を確認
ls -l attendance.db

# データベースを再作成
rm attendance.db
# （プログラムを再起動すると自動的に再作成されます）
```

---

#### 5. LCD関連のエラー

**エラーメッセージ**:
```
[LCD] 初期化失敗: Permission denied - LCD機能を無効化
[情報] LCD機能無効
```

**原因**:
- I2Cが有効化されていない
- I2Cアドレスが間違っている
- LCDが接続されていない

**対処法**:
```bash
# I2Cを有効化
sudo raspi-config
# Interface Options → I2C → Enable

# I2Cデバイスを確認
i2cdetect -y 1

# 再起動
sudo reboot
```

**重要**: LCDが使えなくても、カード読み取りは動作します。

---

## 📊 エラー処理のまとめ

### エラーが発生してもプログラムは継続する機能

| 機能 | エラー時の動作 | プログラムへの影響 |
|------|---------------|------------------|
| GPIO | 機能を無効化 | なし（カード読み取りは継続） |
| LCD | 機能を無効化 | なし（カード読み取りは継続） |
| サーバー送信 | ローカルに保存 | なし（後で自動再送信） |
| カード読み取り | 再試行 | なし（エラーを記録して継続） |
| リトライ | 次回再試行 | なし（定期的に再試行） |

### エラーが発生するとプログラムが停止する機能

| 機能 | エラー時の動作 | プログラムへの影響 |
|------|---------------|------------------|
| データベース初期化 | エラーを表示して終了 | 停止 |
| メインファイルの読み込み | エラーを表示して終了 | 停止 |

---

## 🎯 重要なポイント

### 1. エラー処理は「継続」が基本

ほとんどのエラーは、機能を無効化するか、エラーを記録して処理を継続します。

### 2. オプション機能は無効でもOK

GPIO、LCD、サーバー送信はオプション機能です。無効でもカード読み取りは動作します。

### 3. エラーログを確認する

エラーメッセージを見れば、何が問題かを判断できます。

### 4. 仮想環境で実行する

カードリーダーが正しく認識されるには、仮想環境で実行する必要があります。

---

## 📝 まとめ

- **エラー処理の基本方針**: エラーが発生しても、可能な限り処理を継続する
- **機能の優先順位**: 
  1. カード読み取り（最重要）
  2. データベース保存（重要）
  3. サーバー送信（重要だが失敗してもOK）
  4. GPIO/LCD表示（オプション）
- **エラーログの重要性**: エラーメッセージを見れば、問題の原因を特定できる

---

## 🔗 関連ドキュメント

- [セットアップガイド](RASPBERRY_PI_SETUP_FROM_SCRATCH.md)
- [トラブルシューティング](TROUBLESHOOTING.md)
- [バージョン管理方針](NO_NEW_VERSIONS.md)

