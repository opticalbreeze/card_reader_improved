# AI コード生成のための効果的なプロンプト作成ガイド

## 目的
AIが過度に慎重にならず、タスクを拒否せず、効率的にコード生成を行うための実践的プロンプト作成ガイド

---

## 📋 基本原則

### 1. **明確性 > 完璧性**
- 「完璧なコード」より「動作するコード」を優先することを明示
- プロトタイプ段階であることを伝える
- 後で改善可能であることを示す

### 2. **範囲の明確化**
- 何をすべきか
- 何をすべきでないか
- どこまで実装するか

### 3. **制約の明示**
- 利用可能な技術スタック
- 環境（OS、Python バージョンなど）
- 外部依存の許容範囲

---

## ✅ 効果的なプロンプトのテンプレート

### 🎯 基本テンプレート

```
【目的】
<何を作りたいか、1-2文で簡潔に>

【技術スタック】
- 言語: <Python 3.x など>
- 主要ライブラリ: <pyscard, requests など>
- OS: <Windows/Linux/macOS/クロスプラットフォーム>

【必須機能】
1. <機能A>
2. <機能B>
3. <機能C>

【オプション機能】
- <あれば嬉しい機能>

【制約・前提】
- テスト環境: <実機なし、シミュレーション可など>
- エラーハンドリング: <基本的でOK/厳密に必要>
- パフォーマンス: <特に気にしない/重要>

【期待品質】
- プロトタイプレベルでOK
- 本番レベル必要
- 教育用途

【明示的な指示】
- 実装できる範囲で書いてください
- 完璧である必要はありません
- 標準的なライブラリの使い方に従ってください
- ハードウェアのテストは不要です
```

---

## 🚀 実践例

### ❌ 拒否されやすいプロンプト例

```
クロスプラットフォームのカードリーダーアプリを作って
```

**問題点:**
- 範囲が広すぎる
- 技術スタックが不明
- 品質期待が不明確
- テスト要件が不明

---

### ✅ 効果的なプロンプト例

```
【目的】
Windows/Linux/macOS で動作する IC カードリーダーのCLIアプリケーションを作成

【技術スタック】
- Python 3.8+
- pyscard (PC/SC対応リーダー用)
- requests (サーバー送信用)
- sqlite3 (ローカルキャッシュ用)

【必須機能】
1. カードIDを読み取る（標準的なPC/SCコマンド使用）
2. サーバーにHTTP POSTで送信
3. 送信失敗時はローカルDBに保存
4. 10分ごとに再送信リトライ
5. 複数リーダー対応（マルチスレッド）

【オプション機能】
- 設定ファイル読み込み
- 重複検出（2秒以内）

【制約・前提】
- 実機テストは不要（標準APIに従う）
- エラーハンドリングは基本的なレベルでOK
- pyscard のドキュメント通りの実装で問題なし

【期待品質】
- プロトタイプレベル
- 動作すればOK、最適化は後で
- コメントは主要部分のみ

【明示的な指示】
- pyscard の標準的な使い方に従ってください
- 実機でのテストは不要です
- 一般的なカードリーダーで動作する標準的なコマンドを使用してください
- 完璧である必要はありません
- まず動くコードを作成し、後で改善します
```

---

## 🎓 ケース別テンプレート

### 1. ハードウェア関連コード

```
【重要な前提】
- ハードウェアの実機テストは不要
- ライブラリの公式ドキュメント通りの実装でOK
- 一般的なデバイスで動作する標準的なコマンドを使用
- エッジケースは後で対応

【技術情報】
- 使用ライブラリ: <ライブラリ名>
- 公式ドキュメント: <URLまたは「標準的な使い方に従う」>
- 対応デバイス: 一般的な<デバイス種別>
```

### 2. クロスプラットフォームアプリ

```
【プラットフォーム】
- 対象OS: Windows/Linux/macOS
- Python標準ライブラリを優先
- OS固有機能は分岐で対応（if sys.platform == ...）

【互換性レベル】
- 完全な互換性は不要
- 各OSで「基本的に動作する」レベルでOK
- OS固有の最適化は後回し
```

### 3. GUI アプリケーション

```
【UI要件】
- フレームワーク: <tkinter/PyQt/など>
- デザイン: シンプルでOK、美しさは後回し
- レスポンシブ: 不要/必要

【優先順位】
1. 機能実装（まず動く）
2. エラーハンドリング
3. UI改善（後で）
4. デザイン（最後）
```

### 4. ネットワーク通信

```
【通信要件】
- プロトコル: HTTP/HTTPS
- エラー処理: タイムアウト、接続エラーの基本的な処理
- リトライ: <必要/不要>
- 認証: <なし/Basic/JWT/など>

【テスト】
- 実サーバーへの接続テストは不要
- モックやスタブで十分
```

### 5. データベース

```
【DB要件】
- 種類: SQLite/PostgreSQL/MySQL/など
- スキーマ: <簡単な説明または「提案してください」>
- マイグレーション: 不要/必要
- パフォーマンス: 小規模データでOK/大規模想定

【データ整合性】
- 基本的な制約でOK
- トランザクション: <不要/必要>
```

---

## 🛡️ AI が過度に慎重になるのを防ぐフレーズ

### 使うべきフレーズ

✅ **「標準的な実装で問題ありません」**
✅ **「ライブラリのドキュメント通りに実装してください」**
✅ **「プロトタイプレベルでOKです」**
✅ **「実機テストは不要です」**
✅ **「動作すればOK、最適化は後で行います」**
✅ **「完璧である必要はありません」**
✅ **「一般的なユースケースに対応すればOKです」**
✅ **「エラーハンドリングは基本的なレベルでOK」**
✅ **「まず動くコードを書いて、後で改善します」**
✅ **「コメントは最小限でOK」**

### 避けるべき曖昧なフレーズ

❌ 「ちゃんとした」コードを書いて
❌ 「本格的な」実装をお願いします
❌ 「完璧に」動作するように
❌ 「全てのエッジケースに対応」
❌ （具体的な指示なしの）「クロスプラットフォーム対応」

---

## 📊 プロンプトの構造例（完全版）

```
## 🎯 プロジェクト概要

ICカード打刻システムのクライアントアプリケーション

---

## 💻 技術仕様

### 言語・環境
- Python 3.8 以上
- Windows/Linux/macOS 対応
- CLI アプリケーション

### 依存ライブラリ
- pyscard: カードリーダー制御
- requests: サーバー通信
- sqlite3: ローカルキャッシュ（標準ライブラリ）

---

## ✨ 必須機能

### 1. カード読み取り
- PC/SC 準拠のカードリーダーから ID を読み取る
- 標準的な APDU コマンドを使用（0xFF 0xCA ...など）
- 複数リーダー対応（マルチスレッド）

### 2. サーバー送信
- エンドポイント: POST /api/attendance
- データ形式: JSON {'idm': string, 'timestamp': ISO8601, 'terminal_id': string}
- タイムアウト: 5秒

### 3. ローカルキャッシュ
- 送信失敗時に SQLite に保存
- 10分ごとにリトライ
- 成功したら削除

### 4. 重複防止
- 同じカードが2秒以内に検出された場合は無視

---

## 🔧 実装上の制約

### テスト環境
- 実機でのテストは不要
- pyscard の標準的な API 使用に従う
- エラーは基本的な try-except で処理

### パフォーマンス
- 小規模利用を想定（1日100回程度の読み取り）
- 最適化は不要

### エラーハンドリング
- 基本的なレベルでOK
- カード接続エラー、ネットワークエラー、DBエラーを catch
- 詳細なロギングは不要、print() で十分

---

## 📝 コーディング規約

- 関数・クラスに docstring（1行でOK）
- 複雑な処理にのみコメント
- 変数名は英語
- PEP 8 に従う（厳密でなくてOK）

---

## 🎨 優先順位

1. **最優先**: 基本機能が動作すること
2. **高**: エラーで落ちないこと
3. **中**: コードの可読性
4. **低**: パフォーマンス最適化
5. **後回し**: 完璧なエラーハンドリング

---

## 🚫 不要なもの

- 単体テストコード（後で書く）
- 詳細なロギング機能
- 設定GUI（後で追加）
- 高度なセキュリティ対策（内部ネットワーク想定）
- パフォーマンス計測

---

## 💡 実装方針

**「まず動くコードを作成し、後で改善する」**

- pyscard の公式ドキュメント通りの標準的な実装でOK
- ハードウェアの実機テストは不要
- 一般的なカードリーダーで動作する汎用的なコマンドを使用
- 完璧である必要はなく、プロトタイプレベルで十分

---

## 📦 成果物

- `client_card_reader.py`: メインプログラム
- `client_config.json`: 設定ファイル（サーバーURL）
- `local_cache.db`: SQLite DB（自動生成）
- `README.md`: 簡単な使い方

---

## ✅ 完了条件

- [ ] カードを読み取れる
- [ ] サーバーに送信できる
- [ ] 送信失敗時にローカル保存できる
- [ ] リトライが動作する
- [ ] 複数リーダーで並列動作する
- [ ] Ctrl+C で正常終了する

**動作すればOK。細かい最適化や完璧なエラー処理は後で行います。**
```

---

## 🔍 チェックリスト

プロンプトを書いたら、以下を確認：

- [ ] 目的が1-2文で明確か
- [ ] 使用技術が具体的に列挙されているか
- [ ] 必須機能とオプション機能が分離されているか
- [ ] 「完璧でなくてOK」と明記されているか
- [ ] テスト環境の制約が明示されているか
- [ ] 優先順位が明確か
- [ ] 不要なものが明記されているか

---

## 📚 参考：よくある拒否理由と対策

| 拒否理由 | 対策 |
|---------|------|
| 「実機でテストできない」 | 「ライブラリのドキュメント通りでOK、実機テスト不要」と明記 |
| 「完璧に書けない」 | 「プロトタイプレベルでOK」と明記 |
| 「全てのエッジケースに対応できない」 | 「一般的なケースのみでOK」と明記 |
| 「セキュリティが心配」 | 「内部ネットワーク想定」「基本的なレベルでOK」と明記 |
| 「パフォーマンステストできない」 | 「小規模利用想定」「最適化不要」と明記 |
| 「クロスプラットフォーム対応が難しい」 | 「標準ライブラリ優先」「OS分岐でOK」と明記 |

---

## 🎓 高度なテクニック

### 1. 段階的アプローチを明示

```
【実装フェーズ】
Phase 1: 最小限の動作（単一リーダー、送信のみ）
Phase 2: ローカルキャッシュ追加
Phase 3: マルチリーダー対応
Phase 4: エラーハンドリング強化

まず Phase 1 から実装してください。
```

### 2. 既存コードを参考として提示

```
【参考コード】
以下のような構造で実装してください：

```python
class Client:
    def __init__(self, server_url):
        self.server = server_url
    
    def process_card(self, card_id):
        # ここを実装
        pass
```

このスケルトンを埋める形で実装をお願いします。
```

### 3. エラー時の振る舞いを明確化

```
【エラー時の動作】
- カード読み取りエラー: 無視して次の読み取りを試みる
- ネットワークエラー: ローカルに保存してリトライ
- DBエラー: エラーメッセージを表示して続行
- 致命的エラー: スタックトレースを表示して終了
```

---

## 🌟 ベストプラクティス

### 1. 最初は狭く、後で広げる
```
「まず単一リーダーで動作するバージョンを作成してください。
マルチリーダー対応は後で追加します。」
```

### 2. サンプルデータを提示
```
【入力例】
カードID: "0123456789ABCDEF"
タイムスタンプ: "2025-10-20T15:30:00"

【出力例】
POST /api/attendance
{"idm": "0123456789ABCDEF", "timestamp": "2025-10-20T15:30:00", "terminal_id": "AA:BB:CC:DD:EE:FF"}
```

### 3. 技術的な不安を取り除く
```
【技術的補足】
- pyscard は PC/SC ラッパーで、標準的な APDU コマンドを送るだけです
- requests は通常の HTTP クライアントライブラリです
- 特殊な知識は不要で、公式ドキュメントの例に従えば動作します
```

---

## 📖 プロンプト例文集

### シンプル版
```
Python で IC カードリーダーから ID を読み取り、HTTP POST で送信する CLI アプリを作成してください。

技術: pyscard, requests
OS: Windows/Linux/macOS
品質: プロトタイプレベルでOK
制約: 実機テスト不要、標準的な実装でOK
```

### 詳細版
```
（上記の完全版テンプレートを使用）
```

### 修正依頼版
```
以下のコードを改善してください：

【現在の問題】
- マルチリーダー対応していない

【期待する改善】
- threading を使って複数リーダーを並列処理
- 重複検出機能の追加（2秒以内は無視）

【制約】
- 既存の構造は維持
- エラーハンドリングは現状レベルでOK
```

---

## 🎯 まとめ：最重要ポイント

1. **「完璧でなくてOK」を必ず明記**
2. **技術スタックを具体的に列挙**
3. **「実機テスト不要」を明示**
4. **優先順位を明確化**
5. **標準的な実装でOKと伝える**

---

## 🔗 関連リソース

- [pyscard ドキュメント](https://pyscard.sourceforge.io/)
- [PC/SC 仕様](https://pcscworkgroup.com/)
- [効果的なプロンプトエンジニアリング](https://platform.openai.com/docs/guides/prompt-engineering)

---

**最後に**: AIは「完璧を求めすぎて何も書かない」より「動くコードをまず書く」方が有用です。この文書のテンプレートを使って、明確で実践的なプロンプトを作成してください。

